import os
#from video_data_optimized import VideoData
from zipfile import ZipFile
import numpy as np

#
# def readVideoData(social_path, video_name):
#     # set the path of BINARY_OUTPUTS folder (where are contained the binary files generated by JM19) for video_name
#     binary_outputs_path = f"{social_path}/BINARY_OUTPUTS_OPTIMIZED"
#     return readZipFile(binary_outputs_path + "/" + video_name + "_binary_output_optimized.zip")

# def readZipFile(file_zip_path):
#     with ZipFile(file_zip_path, 'r') as zip_file:
#         # file_content = zip_file.read("BINARY_OUTPUTS")
#         file_content = zip_file.read("binary_output.xml")
#         picture_frames = VideoData.from_bytes(file_content).pictures[1:] # FIRST FRAME ALWAYS EMPTY
#         return picture_frames

def getFiles(path):
    files = []
    for file in os.listdir(path):
        if os.path.isfile(os.path.join(path, file)):
            files.append(file)
    return files

def getFrames(picture_frames, type):
    frames = []
    for frame in picture_frames:
        if len(frame.sub_pictures[0].slices) > 1:
            print("MULTIPLE SLICES!")
        if len(frame.sub_pictures[0].slices) > 0:
            if frame.sub_pictures[0].slices[0].slice_type.name == type:   # type can be i_slice, p_slice or b_slice
                frames.append(frame.picture_id)
    return frames

def getMacroblocksFromFrame(frame):
    # GET MACROBLOCKS FROM ONE FRAME
    macroblocks = []
    sub_pictures = getSubPicturesFromFrame(frame)
    for sub_pic in sub_pictures:
        slices = getSlicesFromSubPic(sub_pic)
        for slice in slices:
            macroblocks.append(slice.macroblocks)
    return macroblocks

def getSubPicturesFromFrame(frame):
    sub_pictures = []
    if len(frame.sub_pictures[0].slices) > 0:  # check if frame is not empty
        for sub_pic in frame.sub_pictures:
            sub_pictures.append(sub_pic)
    return sub_pictures

def getSlicesFromSubPic(subpicture):
    slices = []
    if len(subpicture.slices) > 0:
        for slice in subpicture.slices:
            slices.append(slice)
    return slices

def expandZeros(list):
    expanded_list = []
    i = 0
    while i < len(list):
        if list[i] == 0:
            num_zeros = list[i + 1]
            expanded_list.extend([0] * num_zeros)
            i += 2
        else:
            expanded_list.append(list[i])
            i += 1
    return expanded_list

def zigzag(input):
    # initializing the variables
    # ----------------------------------
    h = 0
    v = 0

    vmin = 0
    hmin = 0

    vmax = input.shape[0]
    hmax = input.shape[1]

    i = 0

    output = np.zeros((vmax * hmax), dtype=int)
    # ----------------------------------

    while ((v < vmax) and (h < hmax)):

        if ((h + v) % 2) == 0:  # going up

            if (v == vmin):
                output[i] = input[v, h]  # if we got to the first line

                if (h == hmax):
                    v = v + 1
                else:
                    h = h + 1

                i = i + 1

            elif ((h == hmax - 1) and (v < vmax)):  # if we got to the last column
                output[i] = input[v, h]
                v = v + 1
                i = i + 1

            elif ((v > vmin) and (h < hmax - 1)):  # all other cases
                output[i] = input[v, h]
                v = v - 1
                h = h + 1
                i = i + 1


        else:  # going down

            if ((v == vmax - 1) and (h <= hmax - 1)):  # if we got to the last line
                output[i] = input[v, h]
                h = h + 1
                i = i + 1

            elif (h == hmin):  # if we got to the first column
                output[i] = input[v, h]

                if (v == vmax - 1):
                    h = h + 1
                else:
                    v = v + 1

                i = i + 1

            elif ((v < vmax - 1) and (h > hmin)):  # all other cases
                output[i] = input[v, h]
                v = v + 1
                h = h - 1
                i = i + 1

        if ((v == vmax - 1) and (h == hmax - 1)):  # bottom right element
            output[i] = input[v, h]
            break

    return output

